    1. Классы и методы по-умолчанию имеют модификатор PUBLIC. Если я хочу у метода изменить модификатор доступа на package
        то над методом ставлю @PackageScope;
    2. Переменные по умолчанию имеют подификаторы PRIVATE;
    3. Все groovy-классы наследуются не только от класса Object но и реализуют интерфейс GroovyObject;
    4. Groovy скрипты все равно превращаются в java-классы при компиляции;
    5. Примитивы в groovy выпилили. Если даже я напишу примитив, он упакуется в обертку.
    6. Добавлены типы данных:
            - BigInteger - целочисленное.  BigInteger value = 35G
            - BigDecimal - в плавающей точкой. BigDecimal value = 35.3G
    7. Увеличены дефолтные импорты:
        - import java.lang.*
        - import java.util.*
        - import java.io.*
        - import java.net.*
        - import groovy.lang.*
        - import groovy.util.*
        - import java.math.BigInteger
        - import java.math.BigDecimal

    8. В импортах можно делать alias для коллизий имен:
        import java.sql.Date as SqlDate
        и теперь можно вызвать так:
         new SqlDate()

    9. Язык динамический, значит можно юзать динамические типы данных (аналог var в java):
                def value4 = 5
                def value5 = 35G
                def value6 = 3.3G
        Но можем использовать не только в локальных переменных, в параметрах метода и полей и возвращаемый тип!
        Но лучше так уже не применять т.к. ухудшает читаемость. Но это подтверждает возможность использовать
        динамические/статические характеристики кода.

    10. Во время компиляции нет проверок. Т.е. вызвав создание объекта с непустым коструктором нас ругать груви не будет
        т.к. это дигнамический язык и проверка произойдет только в runtime. Если мы хотим проверять на компиляции, то
        нужно поставить @CompileStatic и в этом случае начнет подчеркивать красным, как в Java

    11. Использовать assert полезно т.к. мы сразу увидим, что не так
    12. Операции с переменными:
            - 3 / 2 == 1.5 - если мы холим целочисленное деление, как в java нужно юзать intdiv() - 3.intdiv(2) == 1
            - 2**3 == 8 - возведение в степень
            - == - то же самое, что и equals
            - === сравнит ссылки
            - <=> заменяет compareTo()

    13. Приведение типов
        def result = (int) (3 / 2) // javaStyle
        def result = (3 / 2) as Integer // groovyStyle. Можно так приводить к любому типу данных переопределив метод asType(clazz)

    14. в скрипте можно опустить  ине писать def
    15. char создается ЯВНО и пишется как в java: char value = 'H'
    16. Если не писать return, то return сработает автоматически для последней строки
    17. Строки устроены иначе. Подробности в package com.artifact.lesson7
    18. Closure похож на лямда. Подробности в lesson9. Если одна функция возвращает другую функцию (а Closure это функция)
        то такие функции называют функциями высшего порядка
    19. lesson10 if-else
    20. lesson11 switch
    21. lesson12 Loops те же. Подробности в
    22. DefaultGroovyMethods содержит много утилитных методов, которые мы юзаем
    23. В начале методом в скомпилированных файлах .class создается CallSite[] var1 = $getCallSiteArray - это создался массив
            методов, которые мы будем юзать в этом методе
    24. lesson13 List -
             // Множественное присвоение
                    def (a, b, c) = [3, 5, 7, 9, 10]
              // спрэд оператор
              // в функцию передали массив аргументов хотя там они отдельные
                     func(*[8, 10])
    25. lesson14. Map
    26. lesson15. Ranges (Диапазоны) - это списки. Интерфейс. Его реализуют:
            - EmptyRange
            - IntRange
            - NumberRange
            - ObjectRange
        Если я хочу свои какие-то классы использовать в Range, мне нужно в них реализовать два метода:
            - next()
            - previous()
        Range также реализует метод isCase, поэтому удобно использовать в switch (аналог метода contains)