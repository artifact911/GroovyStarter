    1. Классы и методы по-умолчанию имеют модификатор PUBLIC. Если я хочу у метода изменить модификатор доступа на package
        то над методом ставлю @PackageScope;
    2. Переменные по умолчанию имеют подификаторы PRIVATE;
    3. Все groovy-классы наследуются не только от класса Object но и реализуют интерфейс GroovyObject;
    4. Groovy скрипты все равно превращаются в java-классы при компиляции;
    5. Примитивы в groovy выпилили. Если даже я напишу примитив, он упакуется в обертку.
    6. Добавлены типы данных:
            - BigInteger - целочисленное.  BigInteger value = 35G
            - BigDecimal - в плавающей точкой. BigDecimal value = 35.3G
    7. Увеличены дефолтные импорты:
        - import java.lang.*
        - import java.util.*
        - import java.io.*
        - import java.net.*
        - import groovy.lang.*
        - import groovy.util.*
        - import java.math.BigInteger
        - import java.math.BigDecimal

    8. В импортах можно делать alias для коллизий имен:
        import java.sql.Date as SqlDate
        и теперь можно вызвать так:
         new SqlDate()

    9. Язык динамический, значит можно юзать динамические типы данных (аналог var в java):
                def value4 = 5
                def value5 = 35G
                def value6 = 3.3G
        Но можем использовать не только в локальных переменных, в параметрах метода и полей и возвращаемый тип!
        Но лучше так уже не применять т.к. ухудшает читаемость. Но это подтверждает возможность использовать
        динамические/статические характеристики кода.

    10. Во время компиляции нет проверок. Т.е. вызвав создание объекта с непустым коструктором нас ругать груви не будет
        т.к. это дигнамический язык и проверка произойдет только в runtime. Если мы хотим проверять на компиляции, то
        нужно поставить @CompileStatic и в этом случае начнет подчеркивать красным, как в Java

    11. Использовать assert полезно т.к. мы сразу увидим, что не так
    12. Операции с переменными:
            - 3 / 2 == 1.5 - если мы холим целочисленное деление, как в java нужно юзать intdiv() - 3.intdiv(2) == 1
            - 2**3 == 8 - возведение в степень
            - == - то же самое, что и equals
            - === сравнит ссылки
            - <=> заменяет compareTo()

    13. Приведение типов
        def result = (int) (3 / 2) // javaStyle
        def result = (3 / 2) as Integer // groovyStyle. Можно так приводить к любому типу данных переопределив метод asType(clazz)

    14. в скрипте можно опустить  ине писать def
    15. char создается ЯВНО и пишется как в java: char value = 'H'
    16. Если не писать return, то return сработает автоматически для последней строки
    17. lesson7. Строки устроены иначе. Подробности в package com.artifact.lesson7
    18. lesson9. Closure похож на лямда. Подробности в lesson9. Если одна функция возвращает другую функцию (а Closure это функция)
        то такие функции называют функциями высшего порядка

    19. lesson10 if-else
    20. lesson11 switch
    21. lesson12 Loops те же. Подробности в
    22. DefaultGroovyMethods содержит много утилитных методов, которые мы юзаем. Некоторые из них:
            - boolean any({ closure }) - делаем какое-то условие и если какой-то объект удовлетворяет условиям
                    возвращаем boolean;
            - Collection collect({ closure }) - как и в стриме, возвращаем коллекцию;
            - Object each({ closure }) - итерирование. У кого объекта вызвали метод, тот объект и вернется;
            - Object eachWithIndex({ closure }) - итерирование в предоставлением индекса;
            - boolean every({ closure }) - аналог any, только каждый элемент должен удовлетворять какомй-то условию;
            - Object find({ closure }) - находит первое соответствие нашему условию;
            - Collection findAll({ closure }) - находит все соответствия;
            - int findIndexOf({ closure }) - возвращает индекс по какому-то условию;
            - List findIndexValues({ closure }) - аналог верхнего, но верент все индексы;
            - int findLastIndexOf({ closure }) - индекс последнего подходящего по условию;
            - Object inject({ closure }) - похож на reduce, т.е. когда мы из нашей структуры данных превращаем
                    в одно какое-то значение. Схлопываем все в одно;
            - Collection split({ closure }) - похож на group. Например у нас есть коллекция студентов и мы можем
                    разделить их на две - муж/жен;
            - List grep(Object filter) - похожа на фильтр, но гораздо мощнее.
                    GREP - Global Regular Expression and Print.
    23. В начале методом в скомпилированных файлах .class создается CallSite[] var1 = $getCallSiteArray - это создался массив
            методов, которые мы будем юзать в этом методе

    24. lesson13 List -
             // Множественное присвоение
                    def (a, b, c) = [3, 5, 7, 9, 10]
              // спрэд оператор
              // в функцию передали массив аргументов хотя там они отдельные
                     func(*[8, 10])

    25. lesson14. Map

    26. lesson15. Ranges (Диапазоны) - это списки. Интерфейс. Его реализуют:
            - EmptyRange
            - IntRange
            - NumberRange
            - ObjectRange
        Если я хочу свои какие-то классы использовать в Range, мне нужно в них реализовать два метода:
            - next()
            - previous()
        Range также реализует метод isCase, поэтому удобно использовать в switch (аналог метода contains)

    27. lesson16. Object Iteration
            - все объекты представляются в виде коллекций, но если он один, то это коллекция из одного элента и мы
                можем юзать each();
            - grep(). В shell grep используется только в качестве поиска подстрок в тексте (обычный regex).
                В Groovy же с любыми объектами

    28. isCase юзается в switch, in, grep.
    29. lesson17. OOP.
            - все классы по-умолчанию public, а поля private
            - инициализация объекта подробносте в lesson17

    30. lesson 18. Trait. Mixin
            Trait - что-то в роде интерфейса, только можно еще поля прикручивать. Затем мы его реализовываем в классе
                и теперь в нашем классе есть все поля из этого trait и методы.
            Mixin - существовал до Trait и ставился над классом @Mixin<Class.class> тогда этот клас получал эти поля
                и функционал. Но сейчас Deprecated.
                Но Миксины все еще используются как методы. Мы можем любому классу (хоть String) прикрутить свой класс
                 и в пределах нашего класса String получит сторонний функционал:
                    String.mixin(OopRunner.class)
                 Такие миксины глобальны и невозможно добавить миксин какому-то конкретному объекту.
            Подробности в lesson 18

    31. У объекта мы можем получить все поля, типа как в рефлекшнАпи в виде мапы и там кроме наших полей еще будет поле
            - класс нашего класса:
                                o.properties