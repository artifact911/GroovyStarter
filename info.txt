    1. Классы и методы по-умолчанию имеют модификатор PUBLIC. Если я хочу у метода изменить модификатор доступа на package
        то над методом ставлю @PackageScope;
    2. Переменные по умолчанию имеют подификаторы PRIVATE;
    3. Все groovy-классы наследуются не только от класса Object но и реализуют интерфейс GroovyObject;
    4. Groovy скрипты все равно превращаются в java-классы при компиляции;
    5. Примитивы в groovy выпилили. Если даже я напишу примитив, он упакуется в обертку.
    6. Добавлены типы данных:
            - BigInteger - целочисленное.  BigInteger value = 35G
            - BigDecimal - в плавающей точкой. BigDecimal value = 35.3G
    7. Увеличены дефолтные импорты:
        - import java.lang.*
        - import java.util.*
        - import java.io.*
        - import java.net.*
        - import groovy.lang.*
        - import groovy.util.*
        - import java.math.BigInteger
        - import java.math.BigDecimal

    8. В импортах можно делать alias для коллизий имен:
        import java.sql.Date as SqlDate
        и теперь можно вызвать так:
         new SqlDate()

    9. Язык динамический, значит можно юзать динамические типы данных (аналог var в java):
                def value4 = 5
                def value5 = 35G
                def value6 = 3.3G
        Но можем использовать не только в локальных переменных, в параметрах метода и полей и возвращаемый тип!
        Но лучше так уже не применять т.к. ухудшает читаемость. Но это подтверждает возможность использовать
        динамические/статические характеристики кода.

    10. Во время компиляции нет проверок. Т.е. вызвав создание объекта с непустым коструктором нас ругать груви не будет
        т.к. это дигнамический язык и проверка произойдет только в runtime. Если мы хотим проверять на компиляции, то
        нужно поставить @CompileStatic и в этом случае начнет подчеркивать красным, как в Java